<!DOCTYPE html>
<html>
<head>
  <meta charset='utf8'>
  <script async src="opencv.js" type="text/javascript"></script>
</head>
<body>
  
  <video id="video" autoplay muted playsinline
    style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: contain;
      background: black;  /* 背景が出るので任意で色を */
      z-index: -1;
    ">
  </video>
  <canvas id="movie" ></canvas>
  <canvas id="canvas" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      "></canvas>

  <img id ="overlay" src="nkey.png" style="
    position: absolute;
    width: 75%;
    height: 75%;
    opacity: 0.5;">

  <p id="text" style="
    position: absolute;
    font-size: 30px;
    color: rgba(255, 128, 0, 0.7);
    background-color: rgba(0, 255, 255, 0.5);
    transform: rotate(90deg);
    transform-origin: left top;  /* 回転の中心（必要に応じて） */"></p>

<script>
  const video = document.getElementById('video');// 適当にvideoタグのオブジェクトを取得

  var constrains = { 
    video: {facingMode:   "environment"
    }
  }
  var curSTREAM = null;

  const movie = document.getElementById("movie");
  const canvas = document.getElementById("canvas");

  const ctx = movie.getContext("2d");
  const cty = canvas.getContext("2d");

  const overlay = document.getElementById('overlay');

  const text = document.getElementById("text");

  function drawCameraToCanvas() {
    ctx.drawImage(video, 0, 0, video.width, video.height, 0, 0, movie.width, movie.height);
    let src = cv.imread(movie);

    let hsv = new cv.Mat();
    cv.cvtColor(src, hsv, cv.COLOR_RGB2HSV);

    let rpara = [];
    let rweigth = [];
    let rct = 0;
    const cweight = [1,2.72,3.24,3.61];
    let maxd = movie.width*movie.width + movie.height*movie.height;
    let maxdmat = [];
    for(let i = 0; i < 4; i++){
      maxdmat.push(maxd);
    }

    let mask = new cv.Mat();
    let masks = new cv.Mat();

    let lowerb = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [175, 70, 180, 0]);
    let upperb = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [200, 255, 255, 0]);
    
    cv.inRange(hsv, lowerb, upperb, mask); // 色の範囲でマスク作成
    lowerb.setTo(new cv.Scalar(175, 170, 10, 0));
    upperb.setTo(new cv.Scalar(200, 255, 180, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask);
    lowerb.setTo(new cv.Scalar(0, 70, 180, 0));
    upperb.setTo(new cv.Scalar(5, 255, 255, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask);
    lowerb.setTo(new cv.Scalar(0, 170, 10, 0));
    upperb.setTo(new cv.Scalar(5, 255, 180, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask); //redmask

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE); //ブロブ検出
    const output = src.clone();
    for (let i = 0; i < contours.size(); i++) {
      const area = cv.contourArea(contours.get(i));

      if (area > movie.width*movie.height/2000 && area < movie.width*movie.height/15){
        let para = [];

        // const perimeter = cv.arcLength(contours.get(i), true);
        // // 円形度の計算
        // const circularity = (4 * Math.PI * area) / (perimeter * perimeter);

        // const rect = cv.boundingRect(contours.get(i));
        // const aspectRatio = rect.width / rect.height;
        
        // if (aspectRatio < 3.0 && aspectRatio > (1.0/3)) { 

        const moments = cv.moments(contours.get(i));
        const cx = moments.m10 / moments.m00;
        const cy = moments.m01 / moments.m00;

        para.push(cx);
        para.push(cy);
        para.push(area);
        rpara.push(para);
        rweigth.push([...maxdmat]);
        rct++;
      }
    }

    lowerb.setTo(new cv.Scalar(15, 70, 220, 0));
    upperb.setTo(new cv.Scalar(30, 255, 255, 0));
    cv.inRange(hsv, lowerb, upperb, mask); // 色の範囲でマスク作成
    lowerb.setTo(new cv.Scalar(7, 230, 10, 0));
    upperb.setTo(new cv.Scalar(20, 255, 220, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask);    //yellowmask

    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    for (let i = 0; i < contours.size(); i++) {
      const area = cv.contourArea(contours.get(i));

      const moments = cv.moments(contours.get(i));
      const cx = moments.m10 / moments.m00;
      const cy = moments.m01 / moments.m00;

      for(let j = 0; j < rct; j++){
        if (((rpara[j][2] - area)/ rpara[j][2] < 0.6) && ((rpara[j][2] - area)/ rpara[j][2] > -0.1)){
          const dist = ((rpara[j][0] - cx)*(rpara[j][0] - cx) + (rpara[j][1] - cy)*(rpara[j][1] - cy))/ rpara[j][2] /cweight[2];
          if(rweigth[j][0] > dist){
            rweigth[j][0] = dist;
          }
        }
      }
    }

    lowerb.setTo(new cv.Scalar(65, 70, 170, 0));
    upperb.setTo(new cv.Scalar(82, 255, 255, 0));
    cv.inRange(hsv, lowerb, upperb, mask); // 色の範囲でマスク作成
    lowerb.setTo(new cv.Scalar(55, 180, 4, 0));
    upperb.setTo(new cv.Scalar(78, 255, 190, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask);    //greenmask

    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    for (let i = 0; i < contours.size(); i++) {
      const area = cv.contourArea(contours.get(i));

      const moments = cv.moments(contours.get(i));
      const cx = moments.m10 / moments.m00;
      const cy = moments.m01 / moments.m00;

      for(let j = 0; j < rct; j++){
        if (((rpara[j][2] - area)/ rpara[j][2] < 0.6) && ((rpara[j][2] - area)/ rpara[j][2] > -0.1)){
          const dist = ((rpara[j][0] - cx)*(rpara[j][0] - cx) + (rpara[j][1] - cy)*(rpara[j][1] - cy))/ rpara[j][2] /cweight[1];
          if(rweigth[j][1] > dist){
            rweigth[j][1] = dist;
          }
        }
      }
    }

    lowerb.setTo(new cv.Scalar(90, 50, 150, 0));
    upperb.setTo(new cv.Scalar(105, 255, 255, 0));
    cv.inRange(hsv, lowerb, upperb, mask); // 色の範囲でマスク作成
    lowerb.setTo(new cv.Scalar(95, 150, 10, 0));
    upperb.setTo(new cv.Scalar(111, 255, 150, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask);   //skymask

    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    for (let i = 0; i < contours.size(); i++) {
      const area = cv.contourArea(contours.get(i));

      const moments = cv.moments(contours.get(i));
      const cx = moments.m10 / moments.m00;
      const cy = moments.m01 / moments.m00;

      for(let j = 0; j < rct; j++){
        if (((rpara[j][2] - area)/ rpara[j][2] < 0.6) && ((rpara[j][2] - area)/ rpara[j][2] > -0.1)){
          const dist = ((rpara[j][0] - cx)*(rpara[j][0] - cx) + (rpara[j][1] - cy)*(rpara[j][1] - cy))/ rpara[j][2] /cweight[3];
          if(rweigth[j][2] > dist){
            rweigth[j][2] = dist;
          }
        }
      }
    }

    lowerb.setTo(new cv.Scalar(114, 250, 3, 0));
    upperb.setTo(new cv.Scalar(140, 255, 25, 0));
    cv.inRange(hsv, lowerb, upperb, mask); // 色の範囲でマスク作成
    lowerb.setTo(new cv.Scalar(110, 160, 25, 0));
    upperb.setTo(new cv.Scalar(120, 255, 110, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask);
    lowerb.setTo(new cv.Scalar(105, 10, 100, 0));
    upperb.setTo(new cv.Scalar(122, 255, 255, 0));
    cv.inRange(hsv, lowerb, upperb, masks); // 色の範囲でマスク作成
    cv.add(masks, mask, mask);  //bluemask

    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    for (let i = 0; i < contours.size(); i++) {
      const area = cv.contourArea(contours.get(i));

      const moments = cv.moments(contours.get(i));
      const cx = moments.m10 / moments.m00;
      const cy = moments.m01 / moments.m00;

      for(let j = 0; j < rct; j++){
        if (((rpara[j][2] - area)/ rpara[j][2] < 0.6) && ((rpara[j][2] - area)/ rpara[j][2] > -0.1)){
          const dist = ((rpara[j][0] - cx)*(rpara[j][0] - cx) + (rpara[j][1] - cy)*(rpara[j][1] - cy))/ rpara[j][2] /cweight[0];
          if(rweigth[j][3] > dist){
            rweigth[j][3] = dist;
          }
        }
      }
    }

    // text.textContent = "";

    cty.clearRect(0, 0, canvas.width, canvas.height);

    let rdist = [];
    for(let i = 0; i < rct; i++){
      let weight = 0;
      for(let j=0;j<4;j++){
        weight += rweigth[i][j];
      }
      weight *= 99 + rpara[i][2] / (movie.width*movie.height);
      rdist.push(weight);
      // text.textContent += rpara[i][0].toFixed()+ "," +rpara[i][1].toFixed() + " : " + weight + "\n";
    }
    if(rct > 1){
      let rmax1 = 0;
      let rmax2 = 1;
      if(rdist[rmax2] < rdist[rmax1]){
        rmax1 = 1;
        rmax2 = 0;
      }
      for(let i = 2; i < rct; i++){
        if(rdist[rmax2] > rdist[i]){
          rmax2 = i;
          if(rdist[rmax2] < rdist[rmax1]){
            let temp = rmax2;
            rmax2 = rmax1;
            rmax1 = temp;
          }
        }
      }
      //  // 2. 点を描く
      // cty.beginPath();
      // cty.arc(x, 180, 4, 0, 2 * Math.PI);
      // cty.fillStyle = 'red';
      // cty.fill();
      cv.circle(output, new cv.Point(rpara[rmax1][0], rpara[rmax1][1]), 4, new cv.Scalar(128, 128, 128, 255), -1);
      cv.circle(output, new cv.Point(rpara[rmax2][0], rpara[rmax2][1]), 4, new cv.Scalar(128, 128, 128, 255), -1);
    }else if(rct == 1){
      cv.circle(output, new cv.Point(rpara[0][0], rpara[0][1]), 4, new cv.Scalar(128, 128, 128, 255), -1);
    }

    cv.imshow('movie', output);

    // メモリ解放
    src.delete();
    hsv.delete();
    mask.delete();
    masks.delete();
    lowerb.delete();
    upperb.delete();
    contours.delete();
    hierarchy.delete();
    output.delete();

    // 再度次のフレームを描画するためにrequestAnimationFrameを使う
    requestAnimationFrame(drawCameraToCanvas);
  }

  function vkeybord() {
    console.log("バーチャルキーボード開始");

    console.log(constrains);
    navigator.mediaDevices.getUserMedia(constrains)
    .then(function (stream) {
      curSTREAM = stream;
      video.srcObject = stream; // streamはユーザーのカメラとマイクの情報で、これをvideoの入力ソースにする
      video.play();

      const videoTrack = stream.getVideoTracks()[0];
      // // ビデオトラックの設定を取得
      const settings = videoTrack.getSettings();
      // // カメラの解像度を取得
      video.width  = settings.width;
      video.height = settings.height;
      console.log(video.height);
      text.textContent = settings.width + " : " + settings.height + " , " + canvas.width + " : " + canvas.height;

      const rect = video.getBoundingClientRect();
      overlay.style.left = `${rect.left + rect.width / 2 - overlay.width/2}px`; // 50 = 半分の画像幅
      overlay.style.top = `${rect.top + rect.height / 2 - overlay.height/2}px`;  // 50 = 半分の画像高さ
      text.style.left = `${rect.left + rect.width}px`;
      text.style.top = `${(rect.height - rect.width *4 /3)/2}px`;

      movie.width = 210;
      movie.height = movie.width *video.height /video.width;

      // 映像の準備ができたら描画開始
      video.onplaying = () => {
        drawCameraToCanvas();
      };

      console.log("dl");
    })
    .catch(function(err) {
        console.log("An error occured! " + err);
    })
  }

  window.addEventListener('load' , function(){
    console.log("初期読み込み完了");
    console.log(cv);
    console.log(typeof (cv.imread));
    console.log(video.height);
    
    // video.style = 'display:none';
    movie.style = 'display:none';

    vkeybord();
  });

</script>
</body>
</html>